<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris – Vanilla JS</title>
  <style>
    :root {
      --bg: #0f1220; /* deep navy */
      --panel: #151a2d;
      --accent: #7c9cff;
      --text: #e7ebff;
      --muted: #a3acc3;
      --danger: #ff6b6b;
      --good: #51cf66;
      --warn: #ffd43b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 800px at 70% -10%, #1a2040, var(--bg));
      color: var(--text);
      display: grid; place-items: center;
    }
    .wrap {
      display: grid;
      grid-template-columns: 320px 220px;
      gap: 16px; align-items: start;
      padding: 18px; border-radius: 18px;
      background: linear-gradient(180deg, #12162a, #0f1220);
      box-shadow: var(--shadow);
      border: 1px solid #1f2848;
      max-width: 95vw; width: 540px;
    }
    canvas { display:block; background:#0a0d1a; border-radius: 12px; box-shadow: inset 0 0 0 1px #1e2442; }
    .side { display: grid; gap: 12px; }
    .card { background: var(--panel); border: 1px solid #1f2848; border-radius: 14px; padding: 12px; box-shadow: var(--shadow); }
    .title { font-weight: 700; letter-spacing:.2px; font-size: 14px; color: var(--muted); margin-bottom: 8px; text-transform: uppercase; }
    .grid-preview { display: grid; grid-template-columns: repeat(4, 20px); grid-auto-rows: 20px; gap: 2px; }
    .cell { width: 20px; height: 20px; background:#161c34; border-radius:4px; }
    .cell.f { box-shadow: inset 0 0 0 1px rgba(255,255,255,.08); }
    .stats { display:grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .stats .item { background:#12172a; border:1px solid #1f2848; border-radius:10px; padding:10px; text-align:center; }
    .stats .k { display:block; font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing:.3px; }
    .stats .v { font-size: 18px; font-weight: 800; }
    .btns { display:flex; gap:8px; flex-wrap: wrap; }
    button {
      background: linear-gradient(180deg, #1b2344, #151a32);
      border: 1px solid #26305a; color: var(--text);
      border-radius: 12px; padding: 10px 12px; cursor: pointer; font-weight: 700;
      transition: transform .05s ease, filter .2s ease; box-shadow: var(--shadow);
    }
    button:active { transform: translateY(1px); }
    button.primary { border-color:#3f58ff; outline: 1px solid rgba(124,156,255,.35); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#11162a; border:1px solid #26305a; border-radius:6px; padding:2px 6px; }
    .help { font-size: 12px; color: var(--muted); line-height: 1.45; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .pill { font-size: 11px; color:#0a0d1a; background: var(--accent); border-radius: 999px; padding: 2px 8px; font-weight: 800; }
    @media (max-width: 600px) { .wrap { grid-template-columns: 1fr; max-width: 420px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="board" width="320" height="640" aria-label="Tetris playfield" role="img"></canvas>
    <aside class="side">
      <div class="card">
        <div class="title">Stats</div>
        <div class="stats">
          <div class="item"><span class="k">Score</span><span id="score" class="v">0</span></div>
          <div class="item"><span class="k">Lines</span><span id="lines" class="v">0</span></div>
          <div class="item"><span class="k">Level</span><span id="level" class="v">0</span></div>
          <div class="item"><span class="k">Speed</span><span id="speed" class="v">1.00x</span></div>
        </div>
      </div>

      <div class="card">
        <div class="title">Next</div>
        <div id="next" class="grid-preview" aria-live="polite"></div>
      </div>

      <div class="card">
        <div class="title">Hold</div>
        <div id="hold" class="grid-preview"></div>
      </div>

      <div class="card">
        <div class="title">Controls</div>
        <div class="help">
          <div class="row"><span class="pill">Move</span> <span class="kbd">←</span> <span class="kbd">→</span></div>
          <div class="row"><span class="pill">Soft Drop</span> <span class="kbd">↓</span></div>
          <div class="row"><span class="pill">Rotate</span> <span class="kbd">↑</span> / <span class="kbd">Z</span> / <span class="kbd">X</span></div>
          <div class="row"><span class="pill">Hard Drop</span> <span class="kbd">Space</span></div>
          <div class="row"><span class="pill">Hold</span> <span class="kbd">C</span></div>
          <div class="row"><span class="pill">Pause</span> <span class="kbd">P</span></div>
        </div>
        <div class="btns" style="margin-top:10px;">
          <button class="primary" id="startBtn">Start</button>
          <button id="pauseBtn">Pause</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // --- Configuration ---
    const COLS = 10, ROWS = 20, CELL = 32;
    const BOARD_W = COLS * CELL, BOARD_H = ROWS * CELL;

    const COLORS = {
      I: "#5ee7ff", J: "#6388ff", L: "#ff9f43", O: "#ffd43b",
      S: "#51cf66", T: "#c77dff", Z: "#ff6b6b", ghost: "#2b335c"
    };

    // Tetromino rotation states (clockwise). Each is a 4x4 matrix.
    const SHAPES = {
      I: [
        [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
        [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
        [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
        [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
      ],
      O: [
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      ],
      T: [
        [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,1,0],[0,1,0,0],[0,0,0,0]],
        [[0,1,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]],
      ],
      S: [
        [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]],
        [[0,0,0,0],[0,1,1,0],[1,1,0,0],[0,0,0,0]],
        [[1,0,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]],
      ],
      Z: [
        [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,0,0],[0,1,1,0],[0,0,0,0]],
        [[0,1,0,0],[1,1,0,0],[1,0,0,0],[0,0,0,0]],
      ],
      J: [
        [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,1,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,1,0],[0,0,1,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,0,0],[1,1,0,0],[0,0,0,0]],
      ],
      L: [
        [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
        [[0,1,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]],
        [[0,0,0,0],[1,1,1,0],[1,0,0,0],[0,0,0,0]],
        [[1,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
      ],
    };

    // Super-simple wall kicks (not full SRS, but works nicely)
    const KICKS = [ {x:0,y:0}, {x:1,y:0}, {x:-1,y:0}, {x:0,y:-1}, {x:2,y:0}, {x:-2,y:0} ];

    // Gravity speeds (seconds per row)
    const LEVEL_SPEEDS = [
      0.8, 0.72, 0.63, 0.55, 0.47, 0.4, 0.32, 0.26, 0.2, 0.16,
      0.13, 0.1, 0.08, 0.07, 0.05
    ];

    // --- DOM helpers ---
    const $ = sel => document.querySelector(sel);
    const board = $('#board');
    const ctx = board.getContext('2d');
    const ui = { score: $('#score'), lines: $('#lines'), level: $('#level'), speed: $('#speed'), next: $('#next'), hold: $('#hold') };

    // Initialize previews
    function initPreview(el){
      el.innerHTML = '';
      for(let i=0;i<4*5;i++){ // space for 5 pieces stacked
        const d=document.createElement('div'); d.className='cell'; el.appendChild(d);
      }
    }
    initPreview(ui.next);
    initPreview(ui.hold);

    // --- Game State ---
    let grid, active, queue, hold, canHold, score, lines, level, over, paused;
    let fallTimer = 0, fallInterval = LEVEL_SPEEDS[0];

    const emptyRow = () => Array(COLS).fill(null);
    const makeGrid = () => Array(ROWS).fill(0).map(emptyRow);

    // Safe initial state so the loop can run before Start is pressed
    function initIdle(){
      grid = makeGrid();
      active = null; // <— no active piece yet
      queue = [];
      hold = null; canHold = true;
      score = 0; lines = 0; level = 0; over = false; paused = true; // <— paused until Start
      fallTimer = 0; fallInterval = LEVEL_SPEEDS[level];
      updateSidebar();
      drawBoard();
    }

    function newGame(){
      grid = makeGrid();
      queue = makeBag();
      hold = null; canHold = true;
      active = spawn();
      score = 0; lines = 0; level = 0; over = false; paused = false;
      fallTimer = 0; fallInterval = LEVEL_SPEEDS[level];
      updateSidebar();
      draw();
    }

    // 7-bag randomizer
    function makeBag(){
      const pieces = ['I','J','L','O','S','T','Z'];
      for(let i=pieces.length-1;i>0;i--){
        const j = (Math.random()* (i+1))|0; [pieces[i],pieces[j]] = [pieces[j],pieces[i]];
      }
      return pieces;
    }

    function takeNext(){
      if(queue.length===0) queue = makeBag();
      return queue.shift();
    }

    function spawn(){
      const t = takeNext();
      const piece = { type:t, r:0, x:3, y:0 };
      if(collides(piece, grid)) { over = true; paused = true; }
      return piece;
    }

    function rotate(dir){
      if(over||paused||!active) return;
      const p = {...active, r:(active.r + (dir>0?1:3))%4};
      for(const k of KICKS){
        const test = {...p, x:p.x+k.x, y:p.y+k.y};
        if(!collides(test, grid)) { active = test; draw(); return; }
      }
    }

    function move(dx){
      if(over||paused||!active) return;
      const p = {...active, x: active.x+dx};
      if(!collides(p, grid)){ active = p; draw(); }
    }

    function softDrop(){
      if(over||paused||!active) return;
      const p = {...active, y: active.y+1};
      if(!collides(p, grid)){ active = p; score+=1; draw(); }
      else lockPiece();
    }

    function hardDrop(){
      if(over||paused||!active) return;
      let dist=0; let p={...active};
      while(true){
        const n={...p,y:p.y+1}; if(collides(n, grid)) break; p=n; dist++;
      }
      active = p; score += 2*dist; lockPiece();
    }

    function holdSwap(){
      if(over||paused||!active||!canHold) return;
      const t = active.type;
      if(hold){ active = { type: hold, r:0, x:3, y:0 }; hold = t; }
      else { hold = t; active = spawn(); }
      canHold = false; updateSidebar(); draw();
    }

    function collides(p, g){
      const shape = SHAPES[p.type][p.r];
      for(let r=0;r<4;r++){
        for(let c=0;c<4;c++){
          if(!shape[r][c]) continue;
          const x = p.x + c, y = p.y + r;
          if(x<0||x>=COLS||y>=ROWS) return true;
          if(y>=0 && g[y][x]) return true;
        }
      }
      return false;
    }

    function mergePiece(){
      const shape = SHAPES[active.type][active.r];
      for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){
        const x=active.x+c, y=active.y+r; if(y>=0) grid[y][x]=active.type;
      }
    }

    function clearLines(){
      let cleared = 0;
      for(let r=ROWS-1;r>=0;r--){
        if(grid[r].every(v=>v)){
          grid.splice(r,1); grid.unshift(emptyRow()); cleared++; r++;
        }
      }
      if(cleared){
        const points=[0,100,300,500,800][cleared]*(level+1);
        score += points; lines += cleared; level = Math.min(14, Math.floor(lines/10));
        fallInterval = LEVEL_SPEEDS[level];
      }
    }

    function lockPiece(){
      mergePiece();
      clearLines();
      active = spawn();
      canHold = true;
      updateSidebar();
      draw();
    }

    // --- Rendering ---
    function drawCell(x, y, color, ghost=false){
      const px = x*CELL, py = y*CELL;
      ctx.fillStyle = ghost ? COLORS.ghost : color;
      ctx.fillRect(px+1, py+1, CELL-2, CELL-2);
      if(!ghost){
        const g = ctx.createLinearGradient(px, py, px, py+CELL);
        g.addColorStop(0, 'rgba(255,255,255,.12)');
        g.addColorStop(0.5, 'rgba(255,255,255,.04)');
        g.addColorStop(1, 'rgba(0,0,0,.18)');
        ctx.fillStyle = g;
        ctx.fillRect(px+1, py+1, CELL-2, CELL-2);
      }
    }

    function drawBoard(){
      ctx.clearRect(0,0,BOARD_W,BOARD_H);
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#1a2142';
      for(let x=1;x<COLS;x++){
        ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,BOARD_H); ctx.stroke();
      }
      for(let y=1;y<ROWS;y++){
        ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(BOARD_W,y*CELL); ctx.stroke();
      }
      ctx.globalAlpha = 1;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const t = grid[r][c]; if(t) drawCell(c,r, COLORS[t]);
      }
    }

    function ghostOf(p){
      let g={...p};
      while(!collides({...g, y:g.y+1}, grid)) g.y++;
      return g;
    }

    function drawActive(){
      if(!active) return;
      const shape = SHAPES[active.type][active.r];
      const gh = ghostOf(active);
      for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){
        drawCell(gh.x+c, gh.y+r, COLORS.ghost, true);
      }
      for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){
        drawCell(active.x+c, active.y+r, COLORS[active.type]);
      }
    }

    function draw(){
      drawBoard();
      drawActive();
      if(over){
        ctx.fillStyle = 'rgba(0,0,0,.55)'; ctx.fillRect(0,0,BOARD_W,BOARD_H);
        ctx.fillStyle = '#ffffff'; ctx.font = 'bold 28px ui-sans-serif, system-ui';
        ctx.textAlign='center';
        ctx.fillText('Game Over', BOARD_W/2, BOARD_H/2-10);
        ctx.font = '14px ui-sans-serif, system-ui';
        ctx.fillText('Press Reset to play again', BOARD_W/2, BOARD_H/2+18);
      }
    }

    function updateSidebar(){
      ui.score.textContent = score;
      ui.lines.textContent = lines;
      ui.level.textContent = level;
      const speed = (LEVEL_SPEEDS[0]/LEVEL_SPEEDS[level]).toFixed(2)+'x';
      ui.speed.textContent = speed;
      const list = (queue && queue.length ? queue : []).slice(0,5);
      renderMini(ui.next, list);
      renderMini(ui.hold, hold ? [hold] : []);
    }

    function renderMini(container, list){
      const cells = Array.from(container.children);
      cells.forEach(c=>{c.className='cell'; c.style.background='';});
      let rowOffset=0;
      list.forEach((t)=>{
        const shape = SHAPES[t][0];
        let minR=4, maxR=0, minC=4, maxC=0;
        for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(shape[r][c]){ minR=Math.min(minR,r); maxR=Math.max(maxR,r); minC=Math.min(minC,c); maxC=Math.max(maxC,c); }
        const w = (maxC-minC+1);
        const startCol = Math.floor((4-w)/2);
        for(let r=minR;r<=maxR;r++) for(let c=minC;c<=maxC;c++) if(shape[r][c]){
          const rr = rowOffset + r-minR;
          const cc = startCol + c-minC;
          const idx = rr*4 + cc;
          if(cells[idx]){
            cells[idx].classList.add('f');
            cells[idx].style.background = COLORS[t];
          }
        }
        rowOffset += 4; // each piece uses 4 rows
      });
    }

    // --- Game loop ---
    let last = 0;
    function tick(ts){
      if(!last) last = ts;
      const dt = (ts - last)/1000; last = ts;
      if(!paused && !over && active){
        fallTimer += dt;
        if(fallTimer >= fallInterval){
          fallTimer = 0; // gravity step
          const p = {...active, y: active.y+1};
          if(!collides(p, grid)) { active = p; }
          else { lockPiece(); }
          draw();
        }
      }
      requestAnimationFrame(tick);
    }

    // --- Input ---
    document.addEventListener('keydown', e=>{
      switch(e.code){
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': softDrop(); break;
        case 'ArrowUp': rotate(1); break;
        case 'KeyZ': rotate(-1); break;
        case 'KeyX': rotate(1); break;
        case 'Space': e.preventDefault(); hardDrop(); break;
        case 'KeyC': holdSwap(); break;
        case 'KeyP': togglePause(); break;
      }
    });

    // Simple touch buttons (for mobile)
    const touchControls = (()=>{
      if(matchMedia('(pointer: coarse)').matches){
        const bar = document.createElement('div');
        bar.style.position='fixed'; bar.style.left='0'; bar.style.right='0'; bar.style.bottom='10px'; bar.style.display='flex'; bar.style.justifyContent='center'; bar.style.gap='8px';
        ['◀','▶','⤓','⤒','⏬','⏸'].forEach((t,i)=>{
          const b=document.createElement('button'); b.textContent=t; b.style.padding='12px 14px';
          b.style.background='rgba(21,26,50,.9)'; b.style.border='1px solid #26305a'; b.style.borderRadius='12px'; b.style.color='#fff';
          b.addEventListener('click',()=>{
            if(i===0) move(-1);
            else if(i===1) move(1);
            else if(i===2) rotate(1);
            else if(i===3) hardDrop();
            else if(i===4) softDrop();
            else if(i===5) togglePause();
          });
          bar.appendChild(b);
        });
        document.body.appendChild(bar);
      }
    })();

    function togglePause(){ if(over) return; paused = !paused; $('#pauseBtn').textContent = paused ? 'Resume' : 'Pause'; }

    // --- Buttons ---
    $('#startBtn').addEventListener('click', ()=>{ newGame(); });
    $('#resetBtn').addEventListener('click', ()=>{ newGame(); });
    $('#pauseBtn').addEventListener('click', ()=>{ togglePause(); });

    // --- Minimal self-tests (run once on load; logs to console) ---
    function deepCloneGrid(g){ return g.map(row=>row.slice()); }
    function expect(name, cond){ console.log((cond? '✅':'❌')+" "+name); return !!cond; }
    function runSelfTests(){
      const save = { grid: deepCloneGrid(grid), active, queue: queue?queue.slice():[], hold, canHold, score, lines, level, over, paused, fallTimer, fallInterval };
      try{
        // Test: bag contains 7 unique
        const bag = makeBag();
        expect('bag has 7', bag.length===7);
        expect('bag unique set', new Set(bag).size===7);
        // Collision: out-of-bounds
        const g0 = makeGrid();
        expect('collides left wall', collides({type:'I',r:0,x:-1,y:0}, g0));
        expect('collides right wall', collides({type:'I',r:0,x:COLS-3,y:ROWS}, g0));
        // Ghost drop lands on bottom on empty field
        const ap = {type:'O', r:0, x:3, y:0};
        const gh = ghostOf(ap);
        expect('ghost stays in cols', gh.x>=0 && gh.x<=COLS-2);
        expect('ghost bottom row', gh.y>=ROWS-2 && gh.y<ROWS);
        // Line clear
        const g1 = makeGrid();
        g1[ROWS-1] = Array(COLS).fill('I');
        grid = g1; level=0; lines=0; score=0; // set globals for clearLines scoring
        clearLines();
        expect('bottom cleared', grid[ROWS-1].every(v=>v===null));
        expect('lines incremented', lines===1);
      } finally {
        // restore
        grid = save.grid; active = save.active; queue = save.queue; hold = save.hold; canHold = save.canHold;
        score = save.score; lines = save.lines; level = save.level; over = save.over; paused = save.paused; fallTimer = save.fallTimer; fallInterval = save.fallInterval;
        drawBoard();
      }
    }

    // Kick things off: idle state + loop + self-tests
    initIdle();
    requestAnimationFrame(tick);
    runSelfTests();
  </script>
</body>
</html>
